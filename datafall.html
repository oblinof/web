<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Cascada Interactiva (Sintetizador Avanzado)</title>
    <style>
        /* Estilos para asegurar que el canvas ocupe toda la pantalla sin márgenes */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Evita barras de scroll */
            background-color: #000; /* Fondo oscuro por si acaso */
            font-family: 'Inter', sans-serif;
            color: white;
        }
        canvas {
            display: block;
            touch-action: none; /* Deshabilita acciones táctiles por defecto como zoom o scroll */
            /* El fondo se establece dinámicamente desde JS */
        }
        
        /* Panel de Controles */
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 12px;
            z-index: 100;
            font-size: 13px; /* Más pequeño para más opciones */
            max-width: calc(100% - 40px);
            max-height: calc(100% - 40px);
            overflow-y: auto;
        }
        #controls div {
            margin-bottom: 8px;
            display: flex;
            flex-wrap: wrap; /* Para pantallas pequeñas */
            align-items: center;
        }
        #controls label {
            margin-right: 8px;
            font-weight: bold;
            flex-basis: 110px; /* Ancho fijo para etiquetas */
        }
        #controls select {
            flex-grow: 1;
            padding: 4px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            min-width: 120px;
        }
    </style>
</head>
<body>
    <!-- Panel de Controles -->
    <div id="controls">
        <div>
            <label for="style-select">Estilo Cascada:</label>
            <select id="style-select">
                <option value="classic">Classic</option>
                <option value="rio">Rio</option>
                <option value="sun">Sun (Sol)</option>
                <option value="knights">Knights (Acero)</option>
                <option value="nebula">Nebula</option>
                <option value="matrix">Matrix</option>
                <option value="psychedelic">Psychedelic</option>
            </select>
        </div>
        <div>
            <label for="instrument-select">Instrumento:</label>
            <select id="instrument-select">
                <option value="warm">FM (Campana Cálida)</option>
                <option value="synth">Synth (Grueso)</option>
                <option value="sine">Sine (Puro)</option>
                <option value="triangle">Triangle (Suave)</option>
                <option value="square">Square (8-bit)</option>
                <option value="sawtooth">Sawtooth (Clásico)</option>
            </select>
        </div>
        <div>
            <label for="note-select">Nota Raíz:</label>
            <select id="note-select">
                <option value="C">C</option>
                <option value="C#">C#</option>
                <option value="D">D</option>
                <option value="D#">D#</option>
                <option value="E">E</option>
                <option value="F">F</option>
                <option value="F#">F#</option>
                <option value="G">G</option>
                <option value="G#">G#</option>
                <option value="A">A</option>
                <option value="A#">A#</option>
                <option value="B">B</option>
            </select>
        </div>
        <div>
            <label for="scale-select">Escala:</label>
            <select id="scale-select">
                <option value="pentatonicMinor">Pentatónica Menor</option>
                <option value="major">Mayor</option>
                <option value="minor">Menor Natural</option>
                <option value="chromatic">Cromática (Todas)</option>
            </select>
        </div>
        <div>
            <label for="fx-select">Efecto (Eje Y):</label>
            <select id="fx-select">
                <option value="filter">LFO Filtro (Wah)</option>
                <option value="tremolo">LFO Volumen (Trémolo)</option>
                <option value="vibrato">LFO Tono (Vibrato)</option>
                <option value="resonance">LFO Resonancia (Zzww)</option>
                <option value="Y-Filter">Y -> Frec. Filtro</option>
                <option value="Y-Detune">Y -> Desafinar</option>
                <option value="none">Sin Efecto</option>
            </select>
        </div>
    </div>

    <!-- El lienzo donde se dibujará la cascada -->
    <canvas id="waterfallCanvas"></canvas>

    <script>
        // Espera a que la página cargue para ejecutar el script
        window.addEventListener('load', () => {

            const canvas = document.getElementById('waterfallCanvas');
            const ctx = canvas.getContext('2d');

            // --- Estado Global de la Aplicación ---
            let width, height;
            let particles = [];
            const numParticles = 3000;

            const pointer = { x: null, y: null, isDown: false, interactionRadius: 80 };

            // Objeto para guardar las selecciones del usuario
            const settings = {
                style: 'classic',
                instrument: 'warm',
                rootNote: 'C',
                scale: 'pentatonicMinor',
                fx: 'filter'
            };

            // --- Presets de Estilos de Cascada (7 Estilos) ---
            const waterfallStyles = {
                classic: {
                    name: "Classic",
                    bg: '#020024',
                    fadeAlpha: 0.1,
                    particleColors: [ [210, 80, 70], [210, 80, 70], [0, 0, 100] ],
                    baseSpeed: [2, 6],
                    thickness: 1.5,
                    vxRange: 0.5,
                    damping: 0.97
                },
                rio: {
                    name: "Rio",
                    bg: '#002005',
                    fadeAlpha: 0.15,
                    particleColors: [ [120, 100, 60], [100, 100, 70], [60, 100, 75] ],
                    baseSpeed: [4, 8],
                    thickness: 2.0,
                    vxRange: 1.0,
                    damping: 0.96
                },
                sun: {
                    name: "Sun (Sol)",
                    bg: '#320A00',
                    fadeAlpha: 0.08,
                    particleColors: [ [40, 100, 60], [50, 100, 70], [10, 100, 65] ],
                    baseSpeed: [1, 4],
                    thickness: 2.5,
                    vxRange: 0.2,
                    damping: 0.98
                },
                knights: {
                    name: "Knights (Acero)",
                    bg: '#14141E',
                    fadeAlpha: 0.1,
                    particleColors: [ [240, 10, 70], [0, 0, 90], [0, 0, 50] ],
                    baseSpeed: [3, 7],
                    thickness: 1.0,
                    vxRange: 0.3,
                    damping: 0.95
                },
                nebula: {
                    name: "Nebula",
                    bg: '#100010',
                    fadeAlpha: 0.05,
                    particleColors: [ [300, 100, 70], [260, 100, 80], [200, 100, 75] ],
                    baseSpeed: [0.5, 2],
                    thickness: 3.0,
                    vxRange: 1.5,
                    damping: 0.99 // Flota más
                },
                matrix: {
                    name: "Matrix",
                    bg: '#000000',
                    fadeAlpha: 0.20,
                    particleColors: [ [130, 100, 60], [130, 100, 70], [130, 100, 80] ],
                    baseSpeed: [5, 10], // Muy rápido
                    thickness: 1.2,
                    vxRange: 0.1,
                    damping: 0.9
                },
                psychedelic: {
                    name: "Psychedelic",
                    bg: '#200020',
                    fadeAlpha: 0.1,
                    particleColors: [ [300, 100, 70], [60, 100, 70], [180, 100, 70], [240, 100, 80] ],
                    baseSpeed: [2, 5],
                    thickness: 2.0,
                    vxRange: 2.0, // Muy aleatorio
                    damping: 0.96
                }
            };

            // --- Generador de Escalas ---
            const ScaleGenerator = {
                notes: { 'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11 },
                intervals: {
                    major: [0, 2, 4, 5, 7, 9, 11],
                    minor: [0, 2, 3, 5, 7, 8, 10],
                    pentatonicMinor: [0, 3, 5, 7, 10],
                    chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
                },
                generate(rootNote, scaleType, octaves = 3, baseFreq = 130.81) { // C3
                    const rootOffset = this.notes[rootNote];
                    const intervals = this.intervals[scaleType];
                    let scaleFreqs = [];

                    for (let o = 0; o < octaves; o++) {
                        for (let i = 0; i < intervals.length; i++) {
                            const noteIndex = rootOffset + intervals[i] + (o * 12);
                            const freq = baseFreq * Math.pow(2, noteIndex / 12);
                            scaleFreqs.push(freq);
                        }
                    }
                    const finalNoteIndex = rootOffset + (octaves * 12);
                    scaleFreqs.push(baseFreq * Math.pow(2, finalNoteIndex / 12));
                    return scaleFreqs;
                }
            };

            // --- Clase Partícula ---
            class Particle {
                constructor() {
                    this.style = waterfallStyles[settings.style];
                    this.reset();
                    this.y = Math.random() * height;
                }
                
                setStyle(newStyle) {
                    this.style = newStyle;
                    const speedRange = this.style.baseSpeed[1] - this.style.baseSpeed[0];
                    this.vy = this.style.baseSpeed[0] + Math.random() * speedRange;
                    this.radius = 0.5 + Math.random() * (this.style.thickness - 0.5);
                    this.vx = (Math.random() - 0.5) * this.style.vxRange;

                    const color = this.style.particleColors[Math.floor(Math.random() * this.style.particleColors.length)];
                    this.baseHue = color[0];
                    this.baseSat = color[1];
                    this.baseLight = color[2];
                }

                reset() {
                    this.style = waterfallStyles[settings.style];
                    this.x = Math.random() * width;
                    this.y = -10 - Math.random() * 50;
                    
                    const speedRange = this.style.baseSpeed[1] - this.style.baseSpeed[0];
                    this.vy = this.style.baseSpeed[0] + Math.random() * speedRange;
                    this.vx = (Math.random() - 0.5) * this.style.vxRange;
                    this.radius = 0.5 + Math.random() * (this.style.thickness - 0.5);
                    
                    const color = this.style.particleColors[Math.floor(Math.random() * this.style.particleColors.length)];
                    this.baseHue = color[0];
                    this.baseSat = color[1];
                    this.baseLight = color[2];

                    this.interacting = false;
                    this.interactionHue = Math.random() * 360;
                }

                update() {
                    this.y += this.vy;
                    this.x += this.vx;
                    this.vx *= this.style.damping; // Aplicar amortiguación

                    if (pointer.isDown) {
                        const dx = this.x - pointer.x;
                        const dy = this.y - pointer.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < pointer.interactionRadius) {
                            this.interacting = true;
                            const force = (pointer.interactionRadius - dist) / pointer.interactionRadius;
                            const angle = Math.atan2(dy, dx);
                            
                            this.vx += Math.cos(angle) * force * 2.5;
                            this.vy -= Math.sin(angle) * force * 0.5;
                            
                            this.interactionHue = (this.interactionHue + 15) % 360;

                        } else {
                            this.interacting = false;
                        }
                    } else {
                        this.interacting = false;
                    }

                    if (this.y > height + 10) this.reset();
                    if (this.x < -10) this.x = width + 9;
                    if (this.x > width + 10) this.x = -9;
                }

                draw() {
                    ctx.beginPath();
                    if (this.interacting) {
                        ctx.fillStyle = `hsl(${this.interactionHue}, 100%, 75%)`;
                    } else {
                        ctx.fillStyle = `hsl(${this.baseHue}, ${this.baseSat}%, ${this.baseLight}%)`;
                    }
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // --- Clase AudioSynth (Modificada con 2 Osciladores) ---
            class AudioSynth {
                constructor() {
                    this.audioCtx = null;
                    this.osc1 = null;
                    this.osc2 = null;
                    this.osc1Gain = null;
                    this.osc2Gain = null;
                    this.lfo = null;
                    this.lfoGain = null;
                    this.filter = null;
                    this.mainGain = null;
                    this.isInitialized = false;
                    this.currentScale = [];
                }

                init() {
                    if (this.isInitialized) return;
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Dos osciladores para sonidos gruesos/FM
                    this.osc1 = this.audioCtx.createOscillator();
                    this.osc2 = this.audioCtx.createOscillator();
                    this.osc1Gain = this.audioCtx.createGain();
                    this.osc2Gain = this.audioCtx.createGain();
                    
                    this.filter = this.audioCtx.createBiquadFilter();
                    this.lfo = this.audioCtx.createOscillator();
                    this.lfoGain = this.audioCtx.createGain(); // Controla la *intensidad* del LFO
                    this.mainGain = this.audioCtx.createGain();

                    // Conexiones:
                    // Osc1 -> Osc1Gain ---v
                    //                       -> Filter -> mainGain -> destination
                    // Osc2 -> Osc2Gain ---^
                    this.osc1.connect(this.osc1Gain);
                    this.osc2.connect(this.osc2Gain);
                    this.osc1Gain.connect(this.filter);
                    this.osc2Gain.connect(this.filter);
                    this.filter.connect(this.mainGain);
                    this.mainGain.connect(this.audioCtx.destination);
                    
                    // LFO -> lfoGain -> (se conecta dinámicamente)
                    this.lfo.connect(this.lfoGain);

                    // Valores iniciales
                    this.filter.type = 'lowpass';
                    this.filter.Q.value = 10;
                    this.lfo.type = 'sine';
                    this.mainGain.gain.value = 0;
                    this.lfoGain.gain.value = 0;

                    this.lfo.start();
                    this.osc1.start();
                    this.osc2.start();
                    
                    this.updateSettings(settings); // Aplica settings iniciales
                    this.isInitialized = true;
                }

                // Actualiza el sinte basado en los settings
                updateSettings(newSettings) {
                    if (!this.isInitialized) return;
                    
                    const now = this.audioCtx.currentTime;

                    // 1. Actualizar Escala
                    this.currentScale = ScaleGenerator.generate(newSettings.rootNote, newSettings.scale);

                    // 2. Actualizar Instrumento
                    const baseDetune = 7; // 7 cents para sonidos gruesos
                    this.osc1Gain.gain.setTargetAtTime(1.0, now, 0.01);
                    this.osc2Gain.gain.setTargetAtTime(1.0, now, 0.01);

                    switch(newSettings.instrument) {
                        case 'warm': // FM (Campana Cálida)
                            this.osc1.type = 'sine';
                            this.osc2.type = 'sine';
                            this.osc1Gain.gain.setTargetAtTime(0.5, now, 0.01);
                            this.osc2Gain.gain.setTargetAtTime(0.5, now, 0.01);
                            this.osc1.detune.setTargetAtTime(-baseDetune, now, 0.01);
                            this.osc2.detune.setTargetAtTime(baseDetune, now, 0.01);
                            break;
                        case 'synth': // Synth (Grueso)
                            this.osc1.type = 'sawtooth';
                            this.osc2.type = 'sawtooth';
                            this.osc1Gain.gain.setTargetAtTime(0.5, now, 0.01);
                            this.osc2Gain.gain.setTargetAtTime(0.5, now, 0.01);
                            this.osc1.detune.setTargetAtTime(-baseDetune, now, 0.01);
                            this.osc2.detune.setTargetAtTime(baseDetune, now, 0.01);
                            break;
                        case 'sine':
                            this.osc1.type = 'sine';
                            this.osc1Gain.gain.setTargetAtTime(1.0, now, 0.01);
                            this.osc2Gain.gain.setTargetAtTime(0.0, now, 0.01); // Apagar Osc2
                            break;
                        case 'triangle':
                            this.osc1.type = 'triangle';
                            this.osc1Gain.gain.setTargetAtTime(1.0, now, 0.01);
                            this.osc2Gain.gain.setTargetAtTime(0.0, now, 0.01);
                            break;
                        case 'square':
                            this.osc1.type = 'square';
                            this.osc1Gain.gain.setTargetAtTime(1.0, now, 0.01);
                            this.osc2Gain.gain.setTargetAtTime(0.0, now, 0.01);
                            break;
                        case 'sawtooth':
                            this.osc1.type = 'sawtooth';
                            this.osc1Gain.gain.setTargetAtTime(1.0, now, 0.01);
                            this.osc2Gain.gain.setTargetAtTime(0.0, now, 0.01);
                            break;
                    }

                    // 3. Actualizar Conexiones de FX
                    // Desconectar LFO de todo
                    this.lfoGain.disconnect();
                    // Resetear valores que podrían estar controlados por Y
                    this.filter.frequency.setTargetAtTime(3000, now, 0.01); // Valor default
                    this.filter.Q.setTargetAtTime(10, now, 0.01);
                    this.osc1.detune.setTargetAtTime(newSettings.instrument === 'warm' || newSettings.instrument === 'synth' ? -baseDetune : 0, now, 0.01);
                    this.osc2.detune.setTargetAtTime(newSettings.instrument === 'warm' || newSettings.instrument === 'synth' ? baseDetune : 0, now, 0.01);


                    switch(newSettings.fx) {
                        case 'filter':
                            this.lfoGain.connect(this.filter.frequency);
                            break;
                        case 'tremolo':
                            this.lfoGain.connect(this.mainGain.gain);
                            break;
                        case 'vibrato':
                            this.lfoGain.connect(this.osc1.detune);
                            // No conectar a osc2 para un vibrato más sutil
                            break;
                        case 'resonance':
                            this.lfoGain.connect(this.filter.Q);
                            break;
                        // 'Y-Filter', 'Y-Detune', 'none' no conectan el LFO
                    }
                }

                start() {
                    if (!this.isInitialized) this.init();
                    this.audioCtx.resume();

                    let startGain = 0.3;
                    if (settings.fx === 'tremolo') {
                        // Trémolo modula desde un punto medio
                        startGain = 0.15;
                    }
                    this.mainGain.gain.setTargetAtTime(startGain, this.audioCtx.currentTime, 0.05);
                }

                stop() {
                    if (!this.isInitialized) return;
                    this.mainGain.gain.setTargetAtTime(0, this.audioCtx.currentTime, 0.1);
                }

                // Actualiza el sonido basado en la posición X/Y
                update(x, y) {
                    if (!this.isInitialized || this.currentScale.length === 0) return;

                    const now = this.audioCtx.currentTime;
                    
                    // --- Eje X: Control de Frecuencia (Nota) ---
                    const xNorm = x / width;
                    const scaleIndex = Math.floor(xNorm * this.currentScale.length) % this.currentScale.length;
                    const freq = this.currentScale[scaleIndex];
                    this.osc1.frequency.setTargetAtTime(freq, now, 0.02);
                    this.osc2.frequency.setTargetAtTime(freq, now, 0.02);

                    // --- Eje Y: Control de FX ---
                    const yNorm = y / height; // 0 (arriba) a 1 (abajo)
                    const lfoFreq = 0.5 + yNorm * 9.5; // Velocidad LFO (0.5Hz a 10Hz)
                    
                    // Actualizar LFO Freq siempre, se use o no
                    this.lfo.frequency.setTargetAtTime(lfoFreq, now, 0.05);

                    switch(settings.fx) {
                        case 'filter':
                            const lfoDepthFilter = yNorm * 1000; 
                            this.lfoGain.gain.setTargetAtTime(lfoDepthFilter, now, 0.05);
                            const baseFilterFreq = 1000 + (1 - yNorm) * 3000;
                            this.filter.frequency.setTargetAtTime(baseFilterFreq, now, 0.05);
                            break;
                        case 'tremolo':
                            const lfoDepthTremolo = yNorm * 0.2; 
                            this.lfoGain.gain.setTargetAtTime(lfoDepthTremolo, now, 0.05);
                            break;
                        case 'vibrato':
                            const lfoDepthVibrato = yNorm * 50; // 50 cents de vibrato
                            this.lfoGain.gain.setTargetAtTime(lfoDepthVibrato, now, 0.05);
                            break;
                        case 'resonance':
                            const lfoDepthReso = yNorm * 20; // Q de 0 a 20
                            this.lfoGain.gain.setTargetAtTime(lfoDepthReso, now, 0.05);
                            break;
                        case 'Y-Filter':
                            const filterFreq = 100 + (1 - yNorm) * 6000; // 100Hz (abajo) a 6100Hz (arriba)
                            this.filter.frequency.setTargetAtTime(filterFreq, now, 0.05);
                            break;
                        case 'Y-Detune':
                            const detuneAmount = yNorm * 50; // 0 a 50 cents
                            this.osc1.detune.setTargetAtTime(-detuneAmount, now, 0.05);
                            this.osc2.detune.setTargetAtTime(detuneAmount, now, 0.05);
                            break;
                        case 'none':
                            // No hacer nada con el eje Y
                            break;
                    }
                }
            }
            
            const audioSynth = new AudioSynth();

            // --- Funciones de Configuración y Animación ---

            function setupCanvas() {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
                canvas.style.background = waterfallStyles[settings.style].bg;

                particles = [];
                for (let i = 0; i < numParticles; i++) {
                    particles.push(new Particle());
                }
            }

            // Bucle principal de animación
            function animate() {
                const style = waterfallStyles[settings.style];
                // Truco para convertir hex a rgba
                let r = 0, g = 0, b = 0;
                if (style.bg.startsWith('#')) {
                     r = parseInt(style.bg.slice(1, 3), 16);
                     g = parseInt(style.bg.slice(3, 5), 16);
                     b = parseInt(style.bg.slice(5, 7), 16);
                }
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${style.fadeAlpha})`;
                ctx.fillRect(0, 0, width, height);

                particles.forEach(p => {
                    p.update();
                    p.draw();
                });

                requestAnimationFrame(animate);
            }

            // --- Manejadores de Eventos ---

            function updatePointerPosition(e) {
                if (e.touches) {
                    pointer.x = e.touches[0].clientX;
                    pointer.y = e.touches[0].clientY;
                } else {
                    pointer.x = e.clientX;
                    pointer.y = e.clientY;
                }
            }

            function onPointerDown(e) {
                if (e.target.closest && e.target.closest('#controls')) return;
                e.preventDefault(); // Prevenir scroll/zoom táctil

                updatePointerPosition(e);
                pointer.isDown = true;
                audioSynth.start();
                audioSynth.update(pointer.x, pointer.y);
            }

            function onPointerUp(e) {
                if (!pointer.isDown) return;
                pointer.isDown = false;
                audioSynth.stop();
            }

            function onPointerMove(e) {
                if (pointer.isDown) {
                    e.preventDefault(); // Prevenir scroll/zoom táctil
                    updatePointerPosition(e);
                    audioSynth.update(pointer.x, pointer.y);
                }
            }

            // --- Eventos del UI ---
            document.getElementById('style-select').addEventListener('change', (e) => {
                settings.style = e.target.value;
                canvas.style.background = waterfallStyles[settings.style].bg;
                particles.forEach(p => p.setStyle(waterfallStyles[settings.style]));
            });

            document.getElementById('instrument-select').addEventListener('change', (e) => {
                settings.instrument = e.target.value;
                audioSynth.updateSettings(settings);
            });

            document.getElementById('note-select').addEventListener('change', (e) => {
                settings.rootNote = e.target.value;
                audioSynth.updateSettings(settings);
            });

            document.getElementById('scale-select').addEventListener('change', (e) => {
                settings.scale = e.target.value;
                audioSynth.updateSettings(settings);
            });

            document.getElementById('fx-select').addEventListener('change', (e) => {
                settings.fx = e.target.value;
                audioSynth.updateSettings(settings);
            });


            // Asignar eventos globales
            window.addEventListener('resize', setupCanvas);
            
            canvas.addEventListener('mousedown', onPointerDown);
            window.addEventListener('mouseup', onPointerUp);
            canvas.addEventListener('mouseleave', onPointerUp);
            canvas.addEventListener('mousemove', onPointerMove);

            canvas.addEventListener('touchstart', onPointerDown, { passive: false });
            window.addEventListener('touchend', onPointerUp);
            window.addEventListener('touchcancel', onPointerUp);
            canvas.addEventListener('touchmove', onPointerMove, { passive: false });


            // --- Inicialización ---
            setupCanvas();
            animate();
        });
    </script>
</body>
</html>